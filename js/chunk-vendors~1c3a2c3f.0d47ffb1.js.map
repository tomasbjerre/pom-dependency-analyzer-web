{"version":3,"sources":["webpack:///./node_modules/url/url.js","webpack:///./node_modules/url/util.js","webpack:///./node_modules/tslib/tslib.es6.js"],"names":["punycode","__webpack_require__","util","Url","this","protocol","slashes","auth","host","port","hostname","hash","search","query","pathname","path","href","exports","parse","urlParse","resolve","urlResolve","resolveObject","urlResolveObject","format","urlFormat","protocolPattern","portPattern","simplePathPattern","delims","unwise","concat","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","javascript:","hostlessProtocol","slashedProtocol","http","https","ftp","gopher","file","http:","https:","ftp:","gopher:","file:","querystring","url","parseQueryString","slashesDenoteHost","isObject","u","obj","isString","prototype","call","source","relative","TypeError","queryIndex","indexOf","splitter","uSplit","split","slashRegex","replace","join","rest","trim","length","simplePath","exec","substr","proto","lowerProto","toLowerCase","match","atSign","hostEnd","i","hec","lastIndexOf","slice","decodeURIComponent","parseHost","ipv6Hostname","hostparts","l","part","newpart","j","k","charCodeAt","validParts","notHost","bit","push","unshift","toASCII","p","h","ae","esc","encodeURIComponent","escape","qm","s","Object","keys","stringify","charAt","rel","result","tkeys","tk","tkey","rkeys","rk","rkey","v","relPath","shift","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","pop","isNullOrUndefined","authInHost","isNull","last","hasTrailingSlash","up","splice","isAbsolute","module","arg","d","__webpack_exports__","__decorate","decorators","target","key","desc","c","arguments","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty"],"mappings":"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","file":"js/chunk-vendors~1c3a2c3f.0d47ffb1.js","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n"],"sourceRoot":""}